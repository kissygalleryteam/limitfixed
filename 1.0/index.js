// Generated by CoffeeScript 1.6.3
/*
 * @fileoverview
 * @author wuake<wgk1987@gmail.com>
 * @module limitfixed
*/


/*
  usage

  new LimitFixed(fixedElement, limitElement, {
    align: [],
    offset: []
    holder: true
  });

  TODO 文档注释？@lends Limitfixed
  TODO 内部进行事件注册
*/


(function() {
  KISSY.add(function(S, D, E) {
    var LimitFixed, Manager, UA, def, doc, exports, isIE6, manager;
    doc = document;
    UA = S.UA;
    isIE6 = UA.ie === 6;
    def = {
      align: ['top', 'left'],
      offset: [0, 0],
      holder: false,
      holderCls: "limitfixed-holder",
      forceAbs: false,
      cache: false
    };
    /*
      @class Limitfixed
      @constructor
    */

    LimitFixed = function() {
      return this.init.apply(this, arguments);
    };
    S.augment(LimitFixed, S.EventTarget, {
      init: function(elFixed, elLimit, cfg) {
        this.cfg = S.merge(def, cfg);
        this.elFixed = D.get(elFixed);
        this.elLimit = D.get(elLimit);
        this.isFixed = false;
        this._fixedType = isIE6 ? false : !this.cfg.forceAbs;
        this._limitRange;
        if (this.cfg.holder) {
          this._buildHolder();
        }
        return this.scroll();
      },
      _buildHolder: function() {
        var cls, holder,
          _this = this;
        cls = this.cfg.holderCls || "";
        holder = this.elHolder = D.create("<div class='" + cls + "'></div>");
        D.height(holder, D.outerHeight(this.elFixed));
        D.width(holder, D.outerWidth(this.elFixed));
        D.insertBefore(holder, this.elFixed);
        return this.on('fixed', function(ev) {
          var fixed;
          fixed = ev.isFixed;
          if (fixed) {
            return D.show(holder);
          } else {
            return D.hide(holder);
          }
        });
      },
      scroll: function() {
        var limitRange, offset, range, viewRange;
        viewRange = this.getViewRange();
        limitRange = this.getLimitRange();
        range = this._getCrossRange(viewRange, limitRange);
        if (range === null) {
          this._setFixed(false);
        } else {
          offset = this._getAbsPosition(range, limitRange);
          if (this._fixedType && (offset.top > limitRange.top && parseInt(range.top) === parseInt(offset.top)) && (offset.left > limitRange.left && parseInt(range.left) === parseInt(offset.left)) && this.isFixed && this.fixedRange) {
            offset = null;
          } else {
            this.fixedRange = offset = this._calPosition(offset, range, limitRange, viewRange);
          }
          this._setFixed(true);
        }
        return this._applyStyle(offset);
      },
      getViewRange: function() {
        var height, left, top, width;
        left = D.scrollLeft(doc);
        top = D.scrollTop(doc);
        width = D.viewportWidth();
        height = D.viewportHeight();
        return {
          left: left,
          top: top,
          width: width,
          height: height
        };
      },
      getLimitRange: function(force) {
        if (!this._limitRange || force || !this.cfg.cache) {
          this._limitRange = this._getRange(this.elLimit);
        }
        return this._limitRange;
      },
      _getRange: function(elem) {
        var offset;
        offset = D.offset(elem);
        return {
          left: offset.left,
          top: offset.top,
          width: D.outerWidth(elem),
          height: D.outerHeight(elem)
        };
      },
      _getCrossRange: function(range1, range2) {
        var rt, x1, x2, y1, y2;
        x1 = Math.max(range1.left, range2.left);
        y1 = Math.max(range1.top, range2.top);
        x2 = Math.min(range1.left + range1.width, range2.left + range2.width);
        y2 = Math.min(range1.top + range1.height, range2.top + range2.height);
        if (x1 > x2 || y1 > y2) {
          rt = null;
        } else {
          rt = {
            left: x1,
            top: y1,
            width: x2 - x1,
            height: y2 - y1
          };
        }
        return rt;
      },
      _getUnionRange: function(range1, range2) {
        var x1, x2, y1, y2;
        x1 = Math.min(range1.left, range2.left);
        y1 = Math.min(range1.top, range2.top);
        x2 = Math.max(range1.left + range1.width, range2.left + range2.width);
        y2 = Math.max(range1.top + range1.height, range2.top + range2.height);
        return {
          left: x1,
          top: y1,
          width: x2 - x1,
          height: y2 - y1
        };
      },
      _setFixed: function(fixed) {
        if (fixed === this.isFixed) {
          return;
        }
        this.isFixed = fixed;
        return this.fire('fixed', {
          isFixed: fixed
        });
      },
      _getAbsPosition: function(range, limitRange) {
        var align, fixedHeight, fixedWidth, left, limitBottom, limitRight, rangeBottom, rangeRight, top;
        align = this._getAlign();
        fixedHeight = D.outerHeight(this.elFixed);
        fixedWidth = D.outerWidth(this.elFixed);
        limitRight = limitRange.left + limitRange.width;
        limitBottom = limitRange.top + limitRange.height;
        rangeRight = range.left + range.width;
        rangeBottom = range.top + range.height;
        if (align.topFixed) {
          top = Math.min(range.top, limitBottom - fixedHeight);
        } else if (align.bottomFixed) {
          top = Math.max(rangeBottom - fixedHeight, limitRange.top);
        } else if (align.topStatic) {
          top = Math.min(range.top, limitRange.top);
        } else if (align.bottomStatic) {
          top = Math.max(rangeBottom - fixedHeight, limitBottom - fixedHeight);
        }
        if (align.leftFixed) {
          left = Math.min(range.left, limitRight - fixedWidth);
        } else if (align.rightFixed) {
          left = Math.max(rangeRight - fixedWidth, limitRange.left);
        } else if (align.leftStatic) {
          left = Math.min(range.left, limitRange.left);
        } else if (align.rightStatic) {
          left = Math.max(rangeRight - fixedWidth, limitRight - fixedWidth);
        }
        return {
          left: left,
          top: top
        };
      },
      _calPosition: function(align, range, limitRange, viewRange) {
        var custom, offset, relativeParentContainer;
        if (this._fixedType) {
          offset = {
            left: viewRange.left,
            top: viewRange.top
          };
        } else {
          relativeParentContainer = D.parent(this.elLimit, function(el) {
            return S.inArray(D.css(el, 'position'), ['relative', 'absolute']);
          });
          offset = {
            left: 0,
            top: 0
          };
          if (relativeParentContainer) {
            offset = D.offset(relativeParentContainer);
          } else if (D.contains(this.elLimit, this.elFixed) && S.inArray(D.css(this.elLimit, 'position'), ['relative', 'absolute'])) {
            offset = D.offset(this.elLimit);
          }
        }
        align.left -= offset.left;
        align.top -= offset.top;
        custom = this._getOffset();
        align.left += custom.left || 0;
        align.top += custom.top || 0;
        return align;
      },
      _getOffset: function() {
        var cfg, offset;
        cfg = this.cfg.offset;
        offset = {
          left: 1 * cfg[0] || 0,
          top: 1 * cfg[1] || 0
        };
        return offset;
      },
      _getAlign: function() {
        var align, cfg, fixed, stati;
        cfg = S.makeArray(this.cfg.align);
        stati = cfg[1] || "";
        fixed = cfg[0] || "";
        align = {};
        if (fixed.indexOf('left') !== -1) {
          align.leftFixed = true;
        }
        if (fixed.indexOf('right') !== -1) {
          align.rightFixed = true;
        }
        if (fixed.indexOf('top') !== -1) {
          align.topFixed = true;
        }
        if (fixed.indexOf('bottom') !== -1) {
          align.bottomFixed = true;
        }
        if (stati.indexOf('left') !== -1) {
          align.leftStatic = true;
        }
        if (stati.indexOf('right') !== -1) {
          align.rightStatic = true;
        }
        if (stati.indexOf('top') !== -1) {
          align.topStatic = true;
        }
        if (stati.indexOf('bottom') !== -1) {
          align.bottomStatic = true;
        }
        return align;
      },
      _applyStyle: function(offset) {
        var style;
        if (!this.isFixed) {
          style = {
            position: "static"
          };
        } else {
          style = {
            position: this._fixedType ? 'fixed' : 'absolute'
          };
        }
        return D.css(this.elFixed, S.mix(style, offset));
      }
    });
    /*
      管理对象
    */

    Manager = function(def) {
      var _this = this;
      this.def = def;
      this.collection = [];
      E.on(window, 'scroll resize', function() {
        return S.each(_this.collection, function(it) {
          return it.scroll();
        });
      });
    };
    S.augment(Manager, {
      add: function(elFixed, elLimit, cfg) {
        var instance;
        if (!cfg && S.isPlainObject(elLimit)) {
          cfg = elLimit;
          elLimit = S.UA.chrome ? doc.body : doc.documentElement;
        }
        if (!elFixed || !elLimit) {
          return;
        }
        cfg = S.merge(this.def, cfg);
        instance = new LimitFixed(elFixed, elLimit, cfg);
        this.collection.push(instance);
        return instance;
      }
    });
    manager = new Manager();
    exports = function(elFixed, elLimit, cfg) {
      return manager.add(elFixed, elLimit, cfg);
    };
    return exports;
  }, {
    requires: ['dom', 'event']
  });

}).call(this);
