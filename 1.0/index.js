// Generated by CoffeeScript 1.6.3
/*
 * @fileoverview
 * @author wuake<wgk1987@gmail.com>
 * @module limitfixed
*/

/*
  usage

  new LimitFixed(fixedElement, limitElement, {
    align: [],
    offset: []
    holder: true
  });

  TODO 文档注释？@lends Limitfixed
  TODO 内部进行事件注册
*/

KISSY.add(function(S, D, E) {
  var LimitFixed, UA, def, doc, isIE6;
  doc = document;
  UA = S.UA;
  isIE6 = UA.ie === 6;
  def = {
    align: ['top', 'left'],
    offset: [0, 0],
    shim: false,
    holder: false,
    holderCls: "limitfixed-holder",
    forceAbs: false,
    mobile: false,
    cache: false,
    points: [0, 0]
  };
  /*
    @class Limitfixed
    @constructor
  */

  LimitFixed = function() {
    return this.init.apply(this, arguments);
  };
  S.augment(LimitFixed, S.EventTarget, {
    init: function(elFixed, elLimit, cfg) {
      this.cfg = S.merge(def, cfg);
      this.elFixed = D.get(elFixed);
      this.elLimit = D.get(elLimit);
      this.isFixed = false;
      this._fixedType = isIE6 ? false : !this.cfg.forceAbs;
      this._limitRange;
      if (this.cfg.holder) {
        this._buildHolder();
      }
      return this.scroll();
    },
    _buildHolder: function() {
      var cls, holder,
        _this = this;
      cls = this.cfg.holderCls || "";
      holder = D.create("<div class='" + cls + "'></div>");
      D.height(holder, D.outerHeight(this.elFixed));
      D.width(holder, D.outerWidth(this.elFixed));
      D.insertBefore(holder, this.elFixed);
      return this.on('fixed', function(ev) {
        var fixed;
        fixed = ev.isFixed;
        if (fixed) {
          return D.show(holder);
        } else {
          return D.hide(holder);
        }
      });
    },
    scroll: function() {
      var limitRange, range, viewRange;
      viewRange = this.getViewRange();
      limitRange = this.getLimitRange();
      range = this._getCrossRange(viewRange, limitRange);
      return this._setPosition(range, limitRange, viewRange);
    },
    getViewRange: function() {
      return {
        left: D.scrollLeft(doc),
        top: D.scrollTop(doc),
        width: D.viewportWidth(),
        height: D.viewportHeight()
      };
    },
    getLimitRange: function(force) {
      if (!this._limitRange || force || !this.cfg.cache) {
        this._limitRange = this._getRange(this.elLimit);
      }
      return this._limitRange;
    },
    _getRange: function(elem) {
      var offset;
      offset = D.offset(elem);
      return {
        left: offset.left,
        top: offset.top,
        width: D.outerWidth(elem),
        height: D.outerHeight(elem)
      };
    },
    _getCrossRange: function(range1, range2) {
      var rt, x1, x2, y1, y2;
      x1 = Math.max(range1.left, range2.left);
      y1 = Math.max(range1.top, range2.top);
      x2 = Math.min(range1.left + range1.width, range2.left + range2.width);
      y2 = Math.min(range1.top + range1.height, range2.top + range2.height);
      if (x1 > x2 || y1 > y2) {
        rt = null;
      } else {
        rt = {
          left: x1,
          top: y1,
          width: x2 - x1,
          height: y2 - y1
        };
      }
      return rt;
    },
    _setPosition: function(range, limitRange, viewRange) {
      var offset;
      if (range === null) {
        this._setFixed(false);
      } else {
        offset = this._getPosition(range, limitRange, viewRange);
        if (this._fixedType && (offset.top > limitRange.top && parseInt(range.top) === parseInt(offset.top)) && (offset.left > limitRange.left && parseInt(range.left) === parseInt(offset.left)) && this.isFixed && this.fixedRange) {
          offset = null;
        } else {
          this.fixedRange = offset = this._calPosition(offset, range, limitRange, viewRange);
        }
        this._setFixed(true);
      }
      return this._applyStyle(offset);
    },
    _setFixed: function(fixed) {
      if (fixed === this.isFixed) {
        return;
      }
      this.isFixed = fixed;
      return this.fire('fixed', {
        isFixed: fixed
      });
    },
    _getPosition: function(range, limitRange, viewRange) {
      var align, fixedHeight, fixedWidth, left, top;
      align = this._getAlign();
      fixedHeight = D.outerHeight(this.elFixed);
      fixedWidth = D.outerWidth(this.elFixed);
      if (align.topFixed) {
        top = Math.min(range.top, limitRange.top + limitRange.height - fixedHeight);
      } else if (align.bottomFixed) {
        top = Math.max(range.top + range.height - fixedHeight, limitRange.top);
      } else if (align.topStatic) {
        top = Math.min(range.top, limitRange.top);
      } else if (align.bottomStatic) {
        top = Math.max(range.top + range.height - fixedHeight, limitRange.top + limitRange.height - fixedHeight);
      }
      if (align.leftFixed) {
        left = Math.min(range.left, limitRange.left + limitRange.width - fixedWidth);
      } else if (align.rightFixed) {
        left = Math.max(range.left + range.width - fixedWidth, limitRange.left);
      } else if (align.leftStatic) {
        left = Math.min(range.left, limitRange.left);
      } else if (align.rightStatic) {
        left = Math.max(range.left + range.width - fixedWidth, limitRange.left + limitRange.width - fixedWidth);
      }
      return {
        left: left,
        top: top
      };
    },
    _calPosition: function(align, range, limitRange, viewRange) {
      var custom, offset, relativeParentContainer;
      if (this._fixedType) {
        offset = {
          left: viewRange.left,
          top: viewRange.top
        };
      } else {
        relativeParentContainer = D.parent(this.elLimit, function(el) {
          return S.inArray(D.css(el, 'position'), ['relative', 'absolute']);
        });
        offset = {
          left: 0,
          top: 0
        };
        if (relativeParentContainer) {
          offset = D.offset(relativeParentContainer);
        } else if (D.contains(this.elLimit, this.elFixed) && S.inArray(D.css(this.elLimit, 'position'), ['relative', 'absolute'])) {
          offset = D.offset(this.elLimit);
        }
      }
      align.left -= offset.left;
      align.top -= offset.top;
      custom = this._getOffset();
      align.left = align.left + (custom.left || 0);
      align.top = align.top + (custom.top || 0);
      return align;
    },
    _getZIndex: function() {
      var zindex;
      zindex = D.css(this.elFixed, 'z-index');
      return this.cfg.zIndex || parseInt(zindex, 10) || 999;
    },
    _getOffset: function() {
      var cfg, offset;
      cfg = this.cfg.offset;
      offset = {
        left: 1 * cfg[0] || 0,
        top: 1 * cfg[1] || 0
      };
      return offset;
    },
    _getAlign: function() {
      var align, cfg, fixed, stati;
      cfg = S.makeArray(this.cfg.align);
      stati = (cfg[1] || "").split(" ");
      fixed = cfg[0];
      align = {};
      if (fixed.indexOf('left') !== -1) {
        align.leftFixed = true;
      }
      if (fixed.indexOf('right') !== -1) {
        align.rightFixed = true;
      }
      if (fixed.indexOf('top') !== -1) {
        align.topFixed = true;
      }
      if (fixed.indexOf('bottom') !== -1) {
        align.bottomFixed = true;
      }
      if (stati.indexOf('left') !== -1) {
        align.leftStatic = true;
      }
      if (stati.indexOf('right') !== -1) {
        align.rightStatic = true;
      }
      if (stati.indexOf('top') !== -1) {
        align.topStatic = true;
      }
      if (stati.indexOf('bottom') !== -1) {
        align.bottomStatic = true;
      }
      return align;
    },
    _applyStyle: function(offset) {
      var style;
      if (!this.isFixed) {
        style = {
          position: "static"
        };
      } else {
        style = {
          position: this._fixedType ? 'fixed' : 'absolute',
          zIndex: this._getZIndex()
        };
      }
      return D.css(this.elFixed, S.mix(style, offset));
    },
    _buildIEShim: function() {}
  });
  return LimitFixed;
}, {
  requires: ['dom', 'event']
});
