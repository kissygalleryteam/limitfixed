/*
combined files : 

gallery/limitfixed/1.0/index

*/
// Generated by CoffeeScript 1.6.3
/*
 * @fileoverview
 * @author wuake<wgk1987@gmail.com>
 * @module limitfixed
*/

KISSY.add('gallery/limitfixed/1.0/index',function(S, D, E) {
  /*
    new LimitFixed(fixedElement, limitElement, {
      align: [],
      offset: []
      holder: true
    });
  
    TODO 缓存range结果
    TODO 不实时计算。在某些范围内，fixed模式下，可以不设置style。
    TODO 兼容ios？ -webkit-transform: translate3d(0px, -22px, 0px)
    TODO 文档注释？@lends Limitfixed
  */

  var LimitFixed, UA, def, doc, isIE6;
  doc = document;
  UA = S.UA;
  isIE6 = UA.ie === 6;
  def = {
    align: ['top', 'left'],
    offset: [0, 0],
    shim: false,
    holder: false,
    holderCls: "limitfixed-holder",
    forceAbs: false
  };
  /*
    @class Limitfixed
    @constructor
  */

  LimitFixed = function() {
    return this.init.apply(this, arguments);
  };
  S.augment(LimitFixed, S.EventTarget, {
    init: function(elFixed, elLimit, cfg) {
      this.cfg = S.merge(def, cfg);
      this.elFixed = D.get(elFixed);
      this.elLimit = D.get(elLimit);
      this.isFixed = false;
      this._fixedType = isIE6 ? false : !this.cfg.forceAbs;
      this._bindEvent();
      if (this.cfg.holder) {
        this._buildHolder();
      }
      return this.scroll();
    },
    _bindEvent: function() {
      var _this = this;
      return this.on('fixed', function(ev) {
        var fixed;
        fixed = ev.isFixed;
        if (fixed) {
          return D.show(_this.elFixed);
        } else {
          return D.hide(_this.elFixed);
        }
      });
    },
    _buildHolder: function() {
      var cls, holder;
      cls = this.cfg.holderCls || "";
      holder = D.create("<div class='" + cls + "'></div>");
      D.height(holder, D.outerHeight(this.elFixed));
      D.width(holder, D.outerWidth(this.elFixed));
      return D.insertBefore(holder, this.elFixed);
    },
    setFixed: function(fixed) {
      this.isFixed = fixed;
      return this.fire('fixed', {
        isFixed: fixed
      });
    },
    scroll: function() {
      var limitRange, range, viewRange;
      viewRange = this._getRange();
      limitRange = this._getRange(this.elLimit);
      range = this._getCrossRange(viewRange, limitRange);
      return this.setPosition(range, limitRange, viewRange);
    },
    _getRange: function(elem) {
      var height, left, offset, top, width;
      if (elem) {
        offset = D.offset(elem);
        left = offset.left;
        top = offset.top;
        width = D.outerWidth(elem);
        height = D.outerHeight(elem);
      } else {
        left = D.scrollLeft(doc);
        top = D.scrollTop(doc);
        width = D.viewportWidth();
        height = D.viewportHeight();
      }
      return {
        top: top,
        height: height,
        left: left,
        width: width
      };
    },
    _getCrossRange: function(range1, range2) {
      var rt, x1, x2, y1, y2;
      x1 = Math.max(range1.left, range2.left);
      y1 = Math.max(range1.top, range2.top);
      x2 = Math.min(range1.left + range1.width, range2.left + range2.width);
      y2 = Math.min(range1.top + range1.height, range2.top + range2.height);
      if (x1 > x2 || y1 > y2) {
        rt = null;
      } else {
        rt = {
          left: x1,
          top: y1,
          width: x2 - x1,
          height: y2 - y1
        };
      }
      return rt;
    },
    setPosition: function(range, limitRange, viewRange) {
      var style;
      if (range === null) {
        this.setFixed(false);
        style = {
          position: "static",
          zIndex: ""
        };
      } else {
        this.setFixed(true);
        style = this._calPosition(range, limitRange, viewRange);
      }
      return D.css(this.elFixed, style);
    },
    _calPosition: function(range, limitRange, viewRange) {
      var align, offset, style;
      style = {
        "zIndex": this._getZIndex()
      };
      if (this._fixedType) {
        align = this._calFixPosition(range, limitRange, viewRange);
        style.position = 'fixed';
      } else {
        align = this._calAbsPosition(range, limitRange, viewRange);
        style.position = 'absolute';
      }
      offset = this._getOffset();
      if (offset) {
        align.left = align.left + (offset.left || 0);
        align.top = align.top + (offset.top || 0);
      }
      return S.mix(style, align);
    },
    _getZIndex: function() {
      var zindex;
      zindex = D.css(this.elFixed, 'z-index');
      return this.cfg.zIndex || parseInt(zindex, 10) || 999;
    },
    _getOffset: function() {
      var cfg, offset;
      cfg = this.cfg.offset;
      offset = {
        left: 1 * cfg[0] || 0,
        top: 1 * cfg[1] || 0
      };
      return offset;
    },
    _getAlign: function() {
      var align, cfg, fixed, stati;
      cfg = S.makeArray(this.cfg.align);
      stati = (cfg[1] || "").split(" ");
      fixed = cfg[0];
      align = {};
      if (fixed.indexOf('left') !== -1) {
        align.leftFixed = true;
      }
      if (fixed.indexOf('right') !== -1) {
        align.rightFixed = true;
      }
      if (fixed.indexOf('top') !== -1) {
        align.topFixed = true;
      }
      if (fixed.indexOf('bottom') !== -1) {
        align.bottomFixed = true;
      }
      if (stati.indexOf('left') !== -1) {
        align.leftStatic = true;
      }
      if (stati.indexOf('right') !== -1) {
        align.rightStatic = true;
      }
      if (stati.indexOf('top') !== -1) {
        align.topStatic = true;
      }
      if (stati.indexOf('bottom') !== -1) {
        align.bottomStatic = true;
      }
      return align;
    },
    _calFixPosition: function(range, limitRange, viewRange) {
      var align, fixedHeight, fixedWidth, left, top;
      align = this._getAlign();
      fixedHeight = D.outerHeight(this.elFixed);
      fixedWidth = D.outerWidth(this.elFixed);
      if (align.topFixed) {
        top = Math.min(range.top - viewRange.top, limitRange.top + limitRange.height - fixedHeight - viewRange.top);
      } else if (align.bottomFixed) {
        top = Math.max(range.top + range.height - fixedHeight - viewRange.top, limitRange.top - viewRange.top);
      } else if (align.topStatic) {
        top = Math.min(range.top - viewRange.top, limitRange.top - viewRange.top);
      } else if (align.bottomStatic) {
        top = Math.max(range.top + range.height - fixedHeight - viewRange.top, limitRange.top + limitRange.height - fixedHeight - viewRange.top);
      }
      if (align.leftFixed) {
        left = Math.min(range.left - viewRange.left, limitRange.left + limitRange.width - fixedWidth - viewRange.left);
      } else if (align.rightFixed) {
        left = Math.max(range.left + range.width - fixedWidth - viewRange.left, limitRange.left - viewRange.left);
      } else if (align.leftStatic) {
        left = Math.min(range.left - viewRange.left, limitRange.left - viewRange.left);
      } else if (align.rightStatic) {
        left = Math.max(range.left + range.width - fixedWidth - viewRange.left, limitRange.left + limitRange.width - fixedWidth - viewRange.left);
      }
      return {
        left: left,
        top: top
      };
    },
    _calAbsPosition: function(range, limitRange, viewRange) {
      var align, fixedHeight, fixedWidth, left, offset, relativeParentContainer, top;
      relativeParentContainer = D.parent(this.elLimit, function(el) {
        return S.inArray(D.css(el, 'position'), ['relative', 'absolute']);
      });
      offset = {
        left: 0,
        top: 0
      };
      if (relativeParentContainer) {
        offset = D.offset(relativeParentContainer);
      } else if (D.contains(this.elLimit, this.elFixed) && S.inArray(D.css(this.elLimit, 'position'), ['relative', 'absolute'])) {
        offset = D.offset(this.elLimit);
      }
      fixedHeight = D.outerHeight(this.elFixed);
      fixedWidth = D.outerWidth(this.elFixed);
      align = this._getAlign();
      if (align.topFixed) {
        top = Math.min(range.top, limitRange.top + limitRange.height - fixedHeight) - offset.top;
      } else if (align.bottomFixed) {
        top = Math.max(range.top + range.height - fixedHeight, limitRange.top) - offset.top;
      } else if (align.topStatic) {
        top = Math.min(limitRange.top + viewRange.top, limitRange.top) - offset.top;
      } else if (align.bottomStatic) {
        top = Math.max(range.top + range.height - fixedHeight, limitRange.top + limitRange.height - fixedHeight) - offset.top;
      }
      if (align.leftFixed) {
        left = Math.min(range.left, limitRange.left + limitRange.width - fixedWidth) - offset.left;
      } else if (align.rightFixed) {
        left = Math.max(range.left + range.width - fixedWidth, limitRange.left) - offset.left;
      } else if (align.leftStatic) {
        console && console.log(Math.min(limitRange.left + viewRange.left, limitRange.left), limitRange.left, offset.left);
        left = Math.min(limitRange.left + viewRange.left, limitRange.left) - offset.left;
      } else if (align.rightStatic) {
        left = Math.max(range.left + range.width - fixedWidth, limitRange.left + limitRange.width - fixedWidth) - offset.left;
      }
      return {
        left: left,
        top: top
      };
    },
    _buildIEShim: function() {}
  });
  return LimitFixed;
}, {
  requires: ['dom', 'event']
});

